#ifndef ADL_SQLITE_STATEMENT_H
#define ADL_SQLITE_STATEMENT_H

#include "adl/Adl.h"
#include "adl/SQLiteDatabase.h"
#include "acl/stl/vector.h"
#include "SQLiteConnection.h"

ADL_NAMESPACE_START

class CSQLiteStatement : public ISQLiteCursor
{
public:
    struct CParameter
    {
        virtual ~CParameter(void) {};

        virtual apl_int_t Bind( sqlite3_stmt* apoStmt ) = 0;

        apl_int_t miIndex;
    };

public:
    CSQLiteStatement( CSQLiteConnection& aoConn );

    virtual ~CSQLiteStatement(void);

    /** 
     * Close the cursor itself.
     *
     * This function shall close the cursor itself. The cursor should
     * not be used any more after this call.
     * 
     */
    virtual void Close(void);

    /** 
     * Prepare SQL for parameters binding.
     *
     * This function shall try to prepare the SQL command for parameters 
     * binding. The later calls of BindParam() would bind the parameters to 
     * SQL. Make sure all the parameters are binded before Execute().
     *
     * @param[in]   apcSQLStmt      SQL with parameters format embed. 
     *
     * @retval 0            Prepare success.
     * @retval !=0          Prepare failed.
     *
     */
	virtual apl_int_t Prepare(const char* apcSQLStmt);

    /** 
     * Execute a prepared SQL command (with parameters binding).
     *
     * This function shall try to execute the SQL command which 
     * prepared by Prepare() before (with parameters binding).
     *
     * If the SQL return result set, fetch it with FetchNext().
     *
     * @retval 0            Execute success.
     * @retval !=0          Execute failed.
     *
     */
	virtual apl_int_t Execute(void);

    /** 
     * Execute a SQL command.
     *
     * This function shall try to execute the SQL command apcSQL. 
     *
     * If the SQL return result set, fetch it with FetchNext().
     *
     * If the execute failed, GetErrorCode() and GetErrorMsg()
     * would return a error code and error message about the 
     * error.
     * 
     * @param[in]   apcSql       The Sql to execute, it should end with '\0'.
     *
     * @retval 0            Execute success.
     * @retval !=0          Execute failed.
     *
     */
	virtual apl_int_t Execute(const char* apcSQL);

    /** 
     * Get result of current row from the fetched result set by field index.
     *
     * This function shall try to get result of the auField-th field of 
     * current row which fetch by the latest FetchNext() 
     *
     * Optionaly, if apiLen is not NULL, the length of the field's content
     * in bytes would be return by this pointer. Though usually the result
     * string would terminate with '\0'.
     *
     * Currently, only string fromat is supported for the result returning,
     * and the result is read-only.
     * 
     * @param[in]   auField      Specify the index of field in current row.
     * @param[out]  apiLen       The length in bytes of the result.
     *
     * @retval APL_NULL     Get field failed.
     * @retval !=APL_NULL   The poniter to the field's content in char* 
     *                      format and terminated with '\0'. (Only char*
     *                      are support currently)
     *
     */
	virtual const char* GetField(apl_size_t auField, apl_int_t* apiLen);

    /** 
     * Get result of current row from the fetched result set by field name.
     *
     * This function shall try to get result of the apcFieldName field of 
     * current row which fetch by the latest FetchNext() 
     *
     * Optionaly, if apiLen is not NULL, the length of the field's content
     * in bytes would be return by this pointer. Though usually the result
     * string would terminate with '\0'.
     *
     * Currently, only string fromat is supported for the result returning,
     * and the result is read-only.
     * 
     * @param[in]   apcFieldName    Specify the name of field in current row.
     * @param[out]  apiLen          The length in bytes of the result.
     *
     * @retval APL_NULL     Get field failed.
     * @retval !=APL_NULL   The poniter to the field's content in char* 
     *                      format and terminated with '\0'. (Only char*
     *                      are support currently)
     *
     */
	virtual const char* GetField(const char* apcFieldName, apl_int_t* apiLen);

    /** 
     * Get the field counts of result set.
     *
     * This function shall try to get the field counts of the result set 
     * which generated by the last execution of Execute(...).
     *
     * @retval          The counts of the field in result set.
     *
     */
	virtual apl_size_t GetFieldNameCount(void);

    /** 
     * Get the field name by specify the auIdx(index).
     *
     * This function shall try to get the field name by specify the field 
     * index(auIdx) from the fetched result set which fetched by the last 
     * execution of Execute(apcSQL). 
     *
     * @param[in]   auIdx   The field index.
     *
     * @retval APL_NULL     Get field name failed.
     * @retval !=APL_NULL   Field name corresponding to auIdx.
     *
     */
	virtual const char* GetFieldName(apl_size_t auIdx);

    /** 
     * Get the field index by specify the apcName(field name).
     *
     * This function shall try to get the field index by specify the field 
     * name(apcName) from the fetched result set which fetched by the last 
     * execution of Execute(apcSQL).
     *
     * @param[in]   apcName The field name.
     *
     * @retval >=0     Field index corresponding to apcName.
     * @retval =-1     Get field index failed.
     *
     */
    virtual apl_int_t GetFieldIndex(const char* apcName);

    /** 
     * Get the counts of row in result set.
     *
     * This function shall return the row counts of result set 
     * which generated by the last execute.
     *
     * @retval          Rows in result set.
     *
     */
    virtual apl_int_t GetRowCounts(void); 

    /** 
     * Get the error message of the last DB operation.
     *
     * This function shall try to get the error message of the last
     * DataBase operation. e.g. Execute(), Prepare(), FetchAll().
     *
     * @retval          Error message in string format.
     *
     */
    virtual const char* GetErrorMsg(void);

    /** 
     * Get the error code of the last DB operation.
     *
     * This function shall try to get the error code of the last
     * DataBase operation. e.g. Execute(), Prepare(), FetchAll().
     *
     * @retval          Error code in apl_int_t format.
     *
     */
    virtual apl_int_t GetErrorCode(void);

    /** 
     * Get the affected rows of the last execution.
     *
     * This function shall try to get the affected rows of the last
     * DataBase execution which issued by Execute(...). e.g. 
     * INSERT, DELETE, UPDATE ... 
     *
     * @retval          The affected rows by last execution.
     *
     */
    virtual apl_int_t GetAffectedRows(void);

    /** 
     * Bind parameter for short int. 
     *
     * This function shall try to bind parameter for short int. The 
     * BindParam() series functions are always need between
     * Prepare(const char*) and Execute().
     *
     * @param[in]   apcParamName      The parameter name which provided to
     *                                apcSQLStmt in Prepare(const char*)
     * @param[in]   apiParam          The pointer of the variabe which to 
     *                                be binded.
     *
     * @retval 0            Bind parameter success.
     * @retval !=0          Prepare failed.
     */
    virtual apl_int_t BindParam(const char* apcParamName, apl_int16_t* apiParam);

    /** 
     * Bind parameter for int. 
     *
     * This function shall try to bind parameter for int. The 
     * BindParam() series functions are always need between
     * Prepare(const char*) and Execute().
     *
     * @param[in]   apcParamName      The parameter name which provided to
     *                                apcSQLStmt in Prepare(const char*)
     * @param[in]   apiParam          The pointer of the variabe which to 
     *                                be binded.
     *
     * @retval 0            Bind parameter success.
     * @retval !=0          Prepare failed.
     */
    virtual apl_int_t BindParam(const char* apcParamName, apl_int32_t* apiParam);

    /** 
     * Bind parameter for 64bit int. 
     *
     * This function shall try to bind parameter for 64bit int, long long in 
     * 32bit platform and long(also long long) in 64 bit platform. The 
     * BindParam() series functions are always need between 
     * Prepare(const char*) and Execute().
     *
     * @param[in]   apcParamName      The parameter name which provided to
     *                                apcSQLStmt in Prepare(const char*)
     * @param[in]   apiParam          The pointer of the variabe which to 
     *                                be binded.
     *
     * @retval 0            Bind parameter success.
     * @retval !=0          Prepare failed.
     */
    virtual apl_int_t BindParam(const char* apcParamName, apl_int64_t* apiParam);

    /** 
     * Bind parameter for unsigned int. 
     *
     * This function shall try to bind parameter for unsigned int. The 
     * BindParam() series functions are always need between
     * Prepare(const char*) and Execute().
     *
     * @param[in]   apcParamName      The parameter name which provided to
     *                                apcSQLStmt in Prepare(const char*)
     * @param[in]   apuParam          The pointer of the variabe which to 
     *                                be binded.
     *
     * @retval 0            Bind parameter success.
     * @retval !=0          Prepare failed.
     */
    virtual apl_int_t BindParam(const char* apcParamName, apl_uint32_t* apuParam);

    /** 
     * Bind parameter for chars
     *
     * This function shall try to bind parameter for chars. The 
     * BindParam() series functions are always need between
     * Prepare(const char*) and Execute().
     *
     * @param[in]   apcParamName      The parameter name which provided to
     *                                apcSQLStmt in Prepare(const char*)
     * @param[in]   apcParam          The pointer of the variabe which to 
     *                                be binded.
     * @param[in]   auLen             The size of the char buffer.
     *
     * @retval 0            Bind parameter success.
     * @retval !=0          Prepare failed.
     */
    virtual apl_int_t BindParam(const char* apcParamName, const char* apcParam, apl_size_t auLen);

    /** 
     * Bind parameter for chars/binary
     *
     * This function shall try to bind parameter for chars/binary. The 
     * BindParam() series functions are always need between
     * Prepare(const char*) and Execute().
     *
     * @param[in]   apcParamName      The parameter name which provided to
     *                                apcSQLStmt in Prepare(const char*)
     * @param[in]   apcParam          The pointer of the variabe which to 
     *                                be binded.
     * @param[in]   auLen             The size of the char buffer.
     * @param[in]   abIsBinary        true if you wanna bind binary data, 
                                      or false to bind a string
     *
     * @retval 0            Bind parameter success.
     * @retval !=0          Prepare failed.
     */
    virtual apl_int_t BindParam(const char* apcParamName, const void* apcParam, apl_size_t auLen, bool abIsBinary);

    /** 
     * Bind parameter for float.
     *
     * This function shall try to bind parameter for float. The 
     * BindParam() series functions are always need between
     * Prepare(const char*) and Execute().
     *
     * @param[in]   apcParamName      The parameter name which provided to
     *                                apcSQLStmt in Prepare(const char*)
     * @param[in]   apfParam          The pointer of the variabe which to 
     *                                be binded.
     *
     * @retval 0            Bind parameter success.
     * @retval !=0          Prepare failed.
     */
    virtual apl_int_t BindParam(const char* apcParamName, float* apfParam);
    
    /** 
     * Bind parameter for double.
     *
     * This function shall try to bind parameter for double. The 
     * BindParam() series functions are always need between
     * Prepare(const char*) and Execute().
     *
     * @param[in]   apcParamName      The parameter name which provided to
     *                                apcSQLStmt in Prepare(const char*)
     * @param[in]   apfParam          The pointer of the variabe which to 
     *                                be binded.
     *
     * @retval 0            Bind parameter success.
     * @retval !=0          Prepare failed.
     */
    virtual apl_int_t BindParam(const char* apcParamName, double* apdParam);

    /** 
     * Set the pre-fetch row counts for Fetch() .
     *
     * This function would affect the behaviour of Fetch().
     *
     * By default, the pre-fetch row counts of fetching a result set is 1
     * if this function is not involved. This function could specified the
     * pre-fetch row counts for Fetch(). That's say, when this function is 
     * involved, ADL would try to fetch at most auRows rows to pre-fetch buffer 
     * if there is no row in pre-fetch buffer any more, 
     *
     * When setting auRows to 0, ADL would fetch the whole result set in 
     * to pre-fetch buffer once.
     *
     * @param[in]   auRows  The counts of pre-fetch rows.
     *
     */
    virtual void SetPreFetchRows(apl_size_t auRows);

    /** 
     * Fetch next row from result set.
     * 
     * After the call of this function, get the result with GetField series
     * function.
     *
     * SetPreFetchRows(apl_size_t auRows) would affect the behaviour of this
     * function. By default, it would pre-fetch the whole result in to buffer. 
     * If the pre-fetch counts is SET, it would try to fetch the specified rows 
     * when there is no rows in buffer any more.
     *
     * When the result set is known as very huge, specified the pre-fetch rows
     * with SetPreFetchRows(apl_size_t auRows) is always recommended.
     *
     *
     * @retval =0           Fetch success.
     * @retval !=0          Fetch failed.
     *
     */
    virtual apl_int_t FetchNext(void);

    /** 
     * Set characterset for current cursor.
     * 
     * It would affect the other cursors which get from the same connection.
     *
     * FIXME, currently this is only available for mysql. Because oracle's 
     * characterset behavior could be changed by env variable NLS_LANG.
     *
     * Calling this function is equal to the following 3 statements in mysql:
     *      SET character_set_client = apcCharacterSet;
     *      SET character_set_results = apoCharacterSet;
     *      SET character_set_connection = apoCharacterSet;
     *
     * @param[in]   apoCharacterSet The character set which want to set.
     *
     * @retval =0           Set success.
     * @retval !=0          Set failed.
     *
     */
    virtual apl_int_t SetCharacters(const char* apoCharacterSet);

    /** 
     * Get the last insert row id of the last INSERT statment execution.
     *
     * This function shall try to get the last insert row id of the last
     * DataBase execution which issued by Execute(...). e.g. 
     * INSERT 
     *
     * @retval The last insert row id by last execution.
     *
     */
    virtual apl_int64_t GetLastInsertRowID(void);

protected:
    apl_int_t Step(void);
    
    apl_int_t Finalize(void);

    apl_int_t GetParameterIndex( const char* apcParamName );

    apl_int_t BindAllParameter(void);

private:
    CSQLiteConnection& moConn;
    
    sqlite3_stmt* mpoStmt;

    apl_int_t miPreFetchRows;

    apl_int_t miAffectedRows;

    apl_int64_t mi64LastInsertRowID;

    std::vector<CParameter*> moParameteres;
    
    apl_int_t miLastErrcode;
    
    char macLastMessage[256];
};

ADL_NAMESPACE_END

#endif//ADL_NAMESPACE_START

