///////////////////////////////////////////////////////////
//  Adl.h
//  Interface of ADL 
//  Created on:      19-10-2009 14:28:01
//  Original author: hezk
///////////////////////////////////////////////////////////

#if !defined(ADL_H)
#define ADL_H

#include "apl/apl.h"
#include "acl/TimeValue.h"
#include <syslog.h>

#define ADL_NAMESPACE_START namespace adl {

#define ADL_NAMESPACE_END }

ADL_NAMESPACE_START 


//Threads may not share the module.
#define THREAD_SAFETY_NO (0)
//Threads may share the module, but not connections.
#define THREAD_SAFETY_MODULE (1)     
//Threads may share the module and connections.
#define THREAD_SAFETY_CONNECTION (2) 
//Threads may share the module, connections and cursors.
#define THREAD_SAFETY_CURSOR (3)

/** 
 * @brief SQL statement cursor abstract class defined
 */
class ICursor
{
public:
    virtual ~ICursor(void) {}

    /** 
     * Close the cursor itself.
     *
     * This function shall close the cursor itself. The cursor should
     * not be used any more after this call.
     * 
     */
    virtual void Close(void) = 0;

    /** 
     * Execute a prepared SQL command (with parameters binding).
     *
     * This function shall try to execute the SQL command which 
     * prepared by Prepare() before (with parameters binding).
     *
     * If the SQL return result set, fetch it with FetchNext().
     *
     *
     * @retval 0            Execute success.
     * @retval !=0          Execute failed.
     *
     */
	virtual apl_int_t Execute(void) = 0;

    /** 
     * Execute a SQL command.
     *
     * This function shall try to execute the SQL command apcSQL. 
     *
     * If the SQL return result set, fetch it with FetchNext().
     *
     * If the execute failed, GetErrorCode() and GetErrorMsg()
     * would return a error code and error message about the 
     * error.
     * 
     * @param[in]   apcSql       The Sql to execute, it should end with '\0'.
     *
     * @retval 0            Execute success.
     * @retval !=0          Execute failed.
     *
     */
	virtual apl_int_t Execute(const char* apcSQL) = 0;

    /** 
     * Get result of current row from the fetched result set by field index.
     *
     * This function shall try to get result of the auField-th field of 
     * current row which fetch by the latest FetchNext() 
     *
     * Optionaly, if apiLen is not NULL, the length of the field's content
     * in bytes would be return by this pointer. Though usually the result
     * string would terminate with '\0'.
     *
     * Currently, only string fromat is supported for the result returning,
     * and the result is read-only.
     * 
     * @param[in]   auField      Specify the index of field in current row.
     * @param[out]  apiLen       The length in bytes of the result.
     *
     * @retval APL_NULL     Get field failed.
     * @retval !=APL_NULL   The poniter to the field's content in char* 
     *                      format and terminated with '\0'. (Only char*
     *                      are support currently)
     *
     */
	virtual const char* GetField(apl_size_t auField, apl_int_t* apiLen) = 0;

    /** 
     * Get result of current row from the fetched result set by field name.
     *
     * This function shall try to get result of the apcFieldName field of 
     * current row which fetch by the latest FetchNext() 
     *
     * Optionaly, if apiLen is not NULL, the length of the field's content
     * in bytes would be return by this pointer. Though usually the result
     * string would terminate with '\0'.
     *
     * Currently, only string fromat is supported for the result returning,
     * and the result is read-only.
     * 
     * @param[in]   apcFieldName    Specify the name of field in current row.
     * @param[out]  apiLen          The length in bytes of the result.
     *
     * @retval APL_NULL     Get field failed.
     * @retval !=APL_NULL   The poniter to the field's content in char* 
     *                      format and terminated with '\0'. (Only char*
     *                      are support currently)
     *
     */
	virtual const char* GetField(const char* apcFieldName, apl_int_t* apiLen) = 0;

    /** 
     * Get the field counts of result set.
     *
     * This function shall try to get the field counts of the result set 
     * which generated by the last execution of Execute(...).
     *
     * @retval          The counts of the field in result set.
     *
     */
	virtual apl_size_t GetFieldNameCount(void) = 0;

    /** 
     * Get the field name by specify the auIdx(index).
     *
     * This function shall try to get the field name by specify the field 
     * index(auIdx) from the fetched result set which fetched by the last 
     * execution of Execute(apcSQL). 
     *
     * @param[in]   auIdx   The field index.
     *
     * @retval APL_NULL     Get field name failed.
     * @retval !=APL_NULL   Field name corresponding to auIdx.
     *
     */
	virtual const char* GetFieldName(apl_size_t auIdx) = 0;

    /** 
     * Get the field index by specify the apcName(field name).
     *
     * This function shall try to get the field index by specify the field 
     * name(apcName) from the fetched result set which fetched by the last 
     * execution of Execute(apcSQL).
     *
     * @param[in]   apcName The field name.
     *
     * @retval >=0     Field index corresponding to apcName.
     * @retval =-1     Get field index failed.
     *
     */
    virtual apl_int_t GetFieldIndex(const char* apcName) = 0;

    /** 
     * Get the counts of row in result set.
     *
     * This function shall return the row counts of result set 
     * which generated by the last execute.
     *
     * @retval          Rows in result set.
     *
     */
    virtual apl_int_t GetRowCounts(void) = 0; 

    /** 
     * Get the error message of the last DB operation.
     *
     * This function shall try to get the error message of the last
     * DataBase operation. e.g. Execute(), Prepare(), FetchAll().
     *
     * @retval          Error message in string format.
     *
     */
    virtual const char* GetErrorMsg(void) = 0;

    /** 
     * Get the error code of the last DB operation.
     *
     * This function shall try to get the error code of the last
     * DataBase operation. e.g. Execute(), Prepare(), FetchAll().
     *
     * @retval          Error code in apl_int_t format.
     *
     */
    virtual apl_int_t GetErrorCode(void) = 0;

    /** 
     * Get the affected rows of the last execution.
     *
     * This function shall try to get the affected rows of the last
     * DataBase execution which issued by Execute(...). e.g. 
     * INSERT, DELETE, UPDATE ... 
     *
     * @retval          The affected rows by last execution.
     *
     */
    virtual apl_int_t GetAffectedRows(void) = 0;

    /** 
     * Prepare SQL for parameters binding.
     *
     * This function shall try to prepare the SQL command for parameters 
     * binding. The later calls of BindParam() would bind the parameters to 
     * SQL. Make sure all the parameters are binded before Execute().
     *
     * @param[in]   apcSQLStmt      SQL with parameters format embed. 
     *
     * @retval 0            Prepare success.
     * @retval !=0          Prepare failed.
     *
     */
	virtual apl_int_t Prepare(const char* apcSQLStmt) = 0;

    /** 
     * Bind parameter for short int. 
     *
     * This function shall try to bind parameter for short int. The 
     * BindParam() series functions are always need between
     * Prepare(const char*) and Execute().
     *
     * @param[in]   apcParamName      The parameter name which provided to
     *                                apcSQLStmt in Prepare(const char*)
     * @param[in]   apiParam          The pointer of the variabe which to 
     *                                be binded.
     *
     * @retval 0            Bind parameter success.
     * @retval !=0          Prepare failed.
     */
    virtual apl_int_t BindParam(const char* apcParamName, apl_int16_t* apiParam) = 0;

    /** 
     * Bind parameter for int. 
     *
     * This function shall try to bind parameter for int. The 
     * BindParam() series functions are always need between
     * Prepare(const char*) and Execute().
     *
     * @param[in]   apcParamName      The parameter name which provided to
     *                                apcSQLStmt in Prepare(const char*)
     * @param[in]   apiParam          The pointer of the variabe which to 
     *                                be binded.
     *
     * @retval 0            Bind parameter success.
     * @retval !=0          Prepare failed.
     */
    virtual apl_int_t BindParam(const char* apcParamName, apl_int32_t* apiParam) = 0;

    /** 
     * Bind parameter for 64bit int. 
     *
     * This function shall try to bind parameter for 64bit int, long long in 
     * 32bit platform and long(also long long) in 64 bit platform. The 
     * BindParam() series functions are always need between 
     * Prepare(const char*) and Execute().
     *
     * @param[in]   apcParamName      The parameter name which provided to
     *                                apcSQLStmt in Prepare(const char*)
     * @param[in]   apiParam          The pointer of the variabe which to 
     *                                be binded.
     *
     * @retval 0            Bind parameter success.
     * @retval !=0          Prepare failed.
     */
    virtual apl_int_t BindParam(const char* apcParamName, apl_int64_t* apiParam) = 0;

    /** 
     * Bind parameter for unsigned int. 
     *
     * This function shall try to bind parameter for unsigned int. The 
     * BindParam() series functions are always need between
     * Prepare(const char*) and Execute().
     *
     * @param[in]   apcParamName      The parameter name which provided to
     *                                apcSQLStmt in Prepare(const char*)
     * @param[in]   apuParam          The pointer of the variabe which to 
     *                                be binded.
     *
     * @retval 0            Bind parameter success.
     * @retval !=0          Prepare failed.
     */
    virtual apl_int_t BindParam(const char* apcParamName, apl_uint32_t* apuParam) = 0;

    /** 
     * Bind parameter for chars
     *
     * This function shall try to bind parameter for chars. The 
     * BindParam() series functions are always need between
     * Prepare(const char*) and Execute().
     *
     * @param[in]   apcParamName      The parameter name which provided to
     *                                apcSQLStmt in Prepare(const char*)
     * @param[in]   apcParam          The pointer of the variabe which to 
     *                                be binded.
     * @param[in]   auLen             The size of the char buffer.
     *
     * @retval 0            Bind parameter success.
     * @retval !=0          Prepare failed.
     */
    virtual apl_int_t BindParam(const char* apcParamName, const char* apcParam, apl_size_t auLen) = 0;

    /** 
     * Bind parameter for chars/binary
     *
     * This function shall try to bind parameter for chars/binary. The 
     * BindParam() series functions are always need between
     * Prepare(const char*) and Execute().
     *
     * @param[in]   apcParamName      The parameter name which provided to
     *                                apcSQLStmt in Prepare(const char*)
     * @param[in]   apcParam          The pointer of the variabe which to 
     *                                be binded.
     * @param[in]   auLen             The size of the char buffer.
     * @param[in]   abIsBinary        true if you wanna bind binary data, 
                                      or false to bind a string
     *
     * @retval 0            Bind parameter success.
     * @retval !=0          Prepare failed.
     */
    virtual apl_int_t BindParam(const char* apcParamName, const void* apcParam, apl_size_t auLen, bool abIsBinary) = 0;

    /** 
     * Bind parameter for float.
     *
     * This function shall try to bind parameter for float. The 
     * BindParam() series functions are always need between
     * Prepare(const char*) and Execute().
     *
     * @param[in]   apcParamName      The parameter name which provided to
     *                                apcSQLStmt in Prepare(const char*)
     * @param[in]   apfParam          The pointer of the variabe which to 
     *                                be binded.
     *
     * @retval 0            Bind parameter success.
     * @retval !=0          Prepare failed.
     */
    virtual apl_int_t BindParam(const char* apcParamName, float* apfParam) = 0;
    
    /** 
     * Bind parameter for double.
     *
     * This function shall try to bind parameter for double. The 
     * BindParam() series functions are always need between
     * Prepare(const char*) and Execute().
     *
     * @param[in]   apcParamName      The parameter name which provided to
     *                                apcSQLStmt in Prepare(const char*)
     * @param[in]   apfParam          The pointer of the variabe which to 
     *                                be binded.
     *
     * @retval 0            Bind parameter success.
     * @retval !=0          Prepare failed.
     */
    virtual apl_int_t BindParam(const char* apcParamName, double* apdParam) = 0;

    /** 
     * Set the pre-fetch row counts for Fetch() .
     *
     * This function would affect the behaviour of Fetch().
     *
     * By default, the pre-fetch row counts of fetching a result set is 1
     * if this function is not involved. This function could specified the
     * pre-fetch row counts for Fetch(). That's say, when this function is 
     * involved, ADL would try to fetch at most auRows rows to pre-fetch buffer 
     * if there is no row in pre-fetch buffer any more, 
     *
     * When setting auRows to 0, ADL would fetch the whole result set in 
     * to pre-fetch buffer once.
     *
     * @param[in]   auRows  The counts of pre-fetch rows.
     *
     */
    virtual void SetPreFetchRows(apl_size_t auRows) = 0;

    /** 
     * Fetch next row from result set.
     * 
     * After the call of this function, get the result with GetField series
     * function.
     *
     * SetPreFetchRows(apl_size_t auRows) would affect the behaviour of this
     * function. By default, it would pre-fetch the whole result in to buffer. 
     * If the pre-fetch counts is SET, it would try to fetch the specified rows 
     * when there is no rows in buffer any more.
     *
     * When the result set is known as very huge, specified the pre-fetch rows
     * with SetPreFetchRows(apl_size_t auRows) is always recommended.
     *
     *
     * @retval =0           Fetch success.
     * @retval !=0          Fetch failed.
     *
     */
    virtual apl_int_t FetchNext(void) = 0;

    /** 
     * Set characterset for current cursor.
     * 
     * It would affect the other cursors which get from the same connection.
     *
     * FIXME, currently this is only available for mysql. Because oracle's 
     * characterset behavior could be changed by env variable NLS_LANG.
     *
     * Calling this function is equal to the following 3 statements in mysql:
     *      SET character_set_client = apcCharacterSet;
     *      SET character_set_results = apoCharacterSet;
     *      SET character_set_connection = apoCharacterSet;
     *
     * @param[in]   apoCharacterSet The character set which want to set.
     *
     * @retval =0           Set success.
     * @retval !=0          Set failed.
     *
     */
    virtual apl_int_t SetCharacters(const char* apoCharacterSet) = 0;

};

/** 
 * @brief DataBase connection interface define
 */
class IConnection
{
public:
    virtual ~IConnection(void) {}

    /** 
     * Get a cursor handler from connection.
     *
     * This function shall try to get a cursor from connection. All the 
     * Database operation/query is based on cursor. 
     * Multi-cursors could get from the same connection, but the 
     * cursors are not thread-safety in all database. To see 
     * thread-safety level of a database, use GetThreadSafety() to get 
     * the level.
     *
     * @retval APL_NULL     Can't get a valid cursor handler.
     * @retval !=APL_NULL   Pointer to the cursor handler.
     *
     */
	virtual ICursor* Cursor(void) = 0;

    /** 
     * Begin a transaction.
     *
     * This function shall try to begin a transaction on a connection.
     * Node that, transaction is based on *connection* in ADL (Not
     * based on cursor), the caller should keep in mind that when 
     * multi-cursors sharing the same connection.
     *
     * @retval 0            Begin transaction success.
     * @retval !=0          Begin transaction failed.
     *
     */
    virtual apl_int_t BeginTrans(void) = 0;

    /** 
     * End a transaction and commit.
     *
     * This function shall try to end a transaction on a connection 
     * and commit. All the operations since the call of BeginTrans() 
     * would commit. 
     *
     * @retval 0            Commit and end transaction success.
     * @retval !=0          Commit failed.
     *
     */
    virtual apl_int_t Commit(void) = 0;

    /** 
     * End a transaction and rollback.
     *
     * This function shall try to end a transaction on a connection 
     * and rollback. All the operations since the call of BeginTrans() 
     * would cancle.
     *
     * @retval 0            Rollback and end transaction success.
     * @retval !=0          Rollback failed.
     *
     */
    virtual apl_int_t Rollback(void) = 0;

    /** 
     * Set characterset for current cursor.
     * 
     * It would affect the other cursors which get from the same connection.
     *
     * FIXME, currently this is only available for mysql. Because oracle's 
     * characterset behavior could be changed by env variable NLS_LANG.
     *
     * Calling this function is equal to the following 3 statements in mysql:
     *      SET character_set_client = apcCharacterSet;
     *      SET character_set_results = apoCharacterSet;
     *      SET character_set_connection = apoCharacterSet;
     *
     * @param[in]   apoCharacterSet The character set which want to set.
     *
     * @retval =0           Set success.
     * @retval !=0          Set failed.
     *
     */
    virtual apl_int_t SetCharacters(const char* apoCharacterSet) = 0;

    /** 
     * Get the error message of the last DB operation.
     *
     * This function shall try to get the error message of the last
     * DataBase operation.
     *
     * @retval          Error message in string format.
     *
     */
    virtual const char* GetErrorMsg(void) = 0;

    /** 
     * Get the error code of the last DB operation.
     *
     * This function shall try to get the error code of the last
     * DataBase operation. 
     *
     * @retval          Error code in apl_int_t format.
     *
     */
    virtual apl_int_t GetErrorCode(void) = 0;
};

/** 
 * @brief Database abstract interface class defined
 */
class IDatabase
{
public:
    virtual ~IDatabase(void) {};

    /** 
     * Initialize the Database connections pool.
     *
     * This function shall try to init the DataBase connections pool.
     * It *MUST* be callled before all the other operations.
     *
     * @retval 0     Initialize success.
     * @retval !=0   Initialize failed.
     *
     */
	virtual apl_int_t Init(void) = 0;

    /** 
     * Destroy the DataBase connections pool.
     *
     * Usually, there is no need to call this routine because the 
     * de-constructer of the xxxBase class would have the same effect. It's 
     * provided for caller who want to re-init the pool with Init().
     *
     * This function shall destroy the DataBase connections pool.
     *
     */
	virtual void Destroy(void) = 0;

    /** 
     * Get a connection from pool.
     *
     * This function shall get a connection handler from the connection pool. 
     * All the later operations are based on this handler. This might be a 
     * virtual connection, but the caller should not care about it.
     *
     * @param[in]   aoTimeout     The MAX wait time untill getting a valid 
     *                            connection handler. Default wait forever.
     *
     * @retval APL_NULL     Can't get a valid handler in the specified time.
     * @retval !=APL_NULL   Pointer to the connection handler.
     *
     */
    virtual IConnection* GetConnection(acl::CTimeValue const& aoTimeout = acl::CTimeValue::MAXTIME) = 0;

    /** 
     * Release a connection to pool.
     *
     * This function shall release a connection handler to the connection pool. 
     * All the later operations on a released handler is undefined. In some 
     * case, say the connection timeout, caller could also notify the pool to 
     * destroy this connection by specify the abDestroy flag.
     *
     * @param[in]   apoIConn      The connection which get by GetConnection() 
     *                            before.
     *
     */
    virtual void ReleaseConnection(IConnection* apoIConn) = 0;
    
    /** 
     * Get the error message of the last DB operation.
     *
     * This function shall try to get the error message of the last
     * DataBase operation.
     *
     * @retval          Error message in string format.
     *
     */
    virtual const char* GetErrorMsg(void) = 0;

    /** 
     * Get the error code of the last DB operation.
     *
     * This function shall try to get the error code of the last
     * DataBase operation.
     *
     * @retval          Error code in apl_int_t format.
     *
     */
    virtual apl_int_t GetErrorCode(void) = 0;

    /** 
     * Get the thread_safety level of the module.
     *
     * This function shall return the thread-safety level of the module.
     * Currently, MySql is THREAD_SAFETY_MODULE which means the connection 
     * is not share-able (one cursor VS. one connection). Oracle is 
     * THREAD_SAFETY_CONNECTION, which means the connection is share-able 
     * but not the cursor (multi-cursors VS. one connection).
     *
     * @retval THREAD_SAFETY_NO          Threads may not share the module.
     * @retval THREAD_SAFETY_MODULE      Threads may share the module, but not 
     *                                   connections.
     * @retval THREAD_SAFETY_CONNECTION  Threads may share the module and 
     *                                   connections.
     * @retval THREAD_SAFETY_CURSOR      Threads may share the module, 
     *                                   connections and cursors.
     *
     */
    virtual apl_int_t GetThreadSafety(void) = 0;
};

/** 
 * @brief New a database instance
 * 
 * @param apcCmd 
 * 
 * @returns   
 */
IDatabase* CreateDatabase( char const* apcCmd );

void ReleaseDatabase( IDatabase* apoDatabase );

//////////////////////////////////////////////////////////////////////////////////////////////////////////
class CDataBaseImpl; 

class CDataBase
{

public:

    CDataBase(
            const char* apcUser, 
            const char* apcPasswd, 
            const char* apcHostStr, 
            apl_int_t aiMaxConn = 5, 
            const char* apcDBName = APL_NULL,
            apl_int_t aiPort = 0);

    ~CDataBase();
    /** 
     * Initialize the DataBase connections pool.
     *
     * This function shall try to init the DataBase connections pool.
     * It *MUST* be callled before all the other operations.
     *
     * @retval 0     Initialize success.
     * @retval !=0   Initialize failed.
     *
     */
	apl_int_t Init();

    /** 
     * Destroy the DataBase connections pool.
     *
     * Usually, there is no need to call this routine because the 
     * de-constructer of the xxxBase class would have the same effect. It's 
     * provided for caller who want to re-init the pool with Init().
     *
     * This function shall destroy the DataBase connections pool.
     *
     */
	void Destroy();

    /** 
     * Get a connection from pool.
     *
     * This function shall get a connection handler from the connection pool. 
     * All the later operations are based on this handler. This might be a 
     * virtual connection, but the caller should not care about it.
     *
     * @param[in]   aoTimeout     The MAX wait time untill getting a valid 
     *                            connection handler. Default wait forever.
     *
     * @retval APL_NULL     Can't get a valid handler in the specified time.
     * @retval !=APL_NULL   Pointer to the connection handler.
     *
     */
    IConnection* GetConnection(
            acl::CTimeValue const& aoTimeout = acl::CTimeValue::MAXTIME);

    /** 
     * Release a connection to pool.
     *
     * This function shall release a connection handler to the connection pool. 
     * All the later operations on a released handler is undefined. In some 
     * case, say the connection timeout, caller could also notify the pool to 
     * destroy this connection by specify the abDestroy flag.
     *
     * @param[in]   apoIConn      The connection which get by GetConnection() 
     *                            before.
     *
     */
    void ReleaseConnection(IConnection* apoIConn);
    
    /** 
     * Get the error message of the last DB operation.
     *
     * This function shall try to get the error message of the last
     * DataBase operation.
     *
     * @retval          Error message in string format.
     *
     */
    const char* GetErrorMsg();

    /** 
     * Get the error code of the last DB operation.
     *
     * This function shall try to get the error code of the last
     * DataBase operation.
     *
     * @retval          Error code in apl_int_t format.
     *
     */
    apl_int_t GetErrorCode();

    /** 
     * Get the thread_safety level of the module.
     *
     * This function shall return the thread-safety level of the module.
     * Currently, MySql is THREAD_SAFETY_MODULE which means the connection 
     * is not share-able (one cursor VS. one connection). Oracle is 
     * THREAD_SAFETY_CONNECTION, which means the connection is share-able 
     * but not the cursor (multi-cursors VS. one connection).
     *
     * @retval THREAD_SAFETY_NO          Threads may not share the module.
     * @retval THREAD_SAFETY_MODULE      Threads may share the module, but not 
     *                                   connections.
     * @retval THREAD_SAFETY_CONNECTION  Threads may share the module and 
     *                                   connections.
     * @retval THREAD_SAFETY_CURSOR      Threads may share the module, 
     *                                   connections and cursors.
     *
     */
    apl_int_t GetThreadSafety();

private:

    CDataBaseImpl* mpoImpl;
};


ADL_NAMESPACE_END 


#endif // !defined(ADL_H)
